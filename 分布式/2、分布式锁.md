### 分布式锁的实现方式

#### 1、mysql

基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含**方法名**等字段，并在**方法名字段上创建唯一索引**，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；

2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；

3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；

4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。

5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。

#### 2、redis

一般单机，只存入分布式锁，一般不会有问题

- 原子性：setnx key value
- 添加过期时间 ：expire key time（second）

有可能没有执行完就删除了key，下一个请求进来，就出现线程安全问题

看门狗：线程没有执行完，就刷新自己的过期时间。

生成唯一id：任务执行完，判断id是否是自己的id，不是自己的id，就不做处理

哨兵模式：会出现CAP问题、

红锁：搞五个redis，分别上锁，线程进来了，先判断redis存入数据的数量，如果超过半数，就说明上锁成功，执行完成以后再逐个删除，解决CAP问题



#### 3、zookeeper

基于zookeeper临时有序节点可以实现的分布式锁。

zookeeper的四种文件类型：

持久性文件

有序的持性性文件

临时文件

有序的临时文件



watch

监控文件是否被删除，如果删除了，就会通知其他监控节点的服务。



程序：

（1）创建一个目录mylock；
（2）线程A想获取锁就在mylock目录下创建临时顺序节点；
（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。



线程进来，会判断自己是否是最小的节点，如果是直接执行，如果不是线程Watch监控比自己小的有序临时节点，当上一个节点执行程序完成以后，根据zk的watch机制，会通知监控节点，节点接收到通知以后，会再次判断是否是最小，是最小，就执行，然后删除自己临时节点，通知watch自己的节点的节点



优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。