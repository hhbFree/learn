### 1、kafka（https://blog.csdn.net/qq_35387940/article/details/100514134）

#### 1.1 消息的传播模式

点对点

- 如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。（服务在分布式情况下，就把不同服务设置为同一个消费组下，就会轮循的去消费）

发布/订阅

- 如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用。（就是分组的数量要小于分区的数量，要不然会有分组消费不到消息）

### 2、rabbitMQ

#### 2.1、消息的传播模式

点对点（队列）

- （服务在分布式情况下，就把不同服务设置为绑定同一个队列下，就会轮循的去消费，也可以设置对应routeKey，进行筛选消费）

发布/订阅（交换机）

- fanout/direct/topic/headers中，fanout/direct/topic都是可以的，一般都是topic，这样可以写正则匹配，如果都满足条件的情况下，对应的队列分别都添加数据，服务分别绑定相同的交换机，绑定不同的队列，队列中的数据相同

避免消息堆积？

1） 采用workqueue，多个消费者监听同一队列。

2）接收到消息以后，而是通过线程池，异步消费。

如何避免消息丢失？

1） 消费者的ACK机制。可以防止消费者丢失消息。

但是，如果在消费者消费之前，MQ就宕机了，消息就没了？

2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化



- bindgkey和routeKey的区别

  rabbit队列要看成消费队列，发送消息时，交换机绑定队列和路由，在发送的时候

  当在direct是没有区别的，因为bindgkey和routeKey必须完全一样，才会发送对应的队列

  在topic时，消费端可以做正则匹配，去接受发送端的数据，满足匹配情况的都会发送对应的队列

  
rabbitmq有3种模式，但集群模式是2种。详细如下：

1.1 普通集群模式
queue 创建之后，如果没有其它 policy，消息实体只存在于其中 一个节点，A、B 两个 Rabbitmq 节点仅有相同的元数据，即队列结构，但队列的 数据仅保存有一份，即创建该队列的 rabbitmq 节点（A 节点），当消息进入 A 节 点的 Queue 中后，consumer 从 B 节点拉取时，RabbitMQ 会临时在 A、B 间进行 消息传输，把 A 中的消息实体取出并经过 B 发送给 consumer，所以 consumer 可以连接每一个节点，从中取消息，该模式存在一个问题就是当 A 节点故障后， B 节点无法取到 A 节点中还未消费的消息实体。

1.2 镜像集群模式
把需要的队列做成镜像队列，存在于多个节点，属于 RabbitMQ 的 HA 方案（镜 像模式是在普通模式的基础上，增加一些镜像策略）
该模式解决了普通模式中的数据丢失问题，其实质和普通模式不同之处在于，消 息实体会主动在镜像节点间同步，而不是在 consumer 取数据时临时拉取，该模 式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之 大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉，所以在 对可靠性要求较高的场合中适用，一个队列想做成镜像队列，需要先设置 policy， 然后客户端创建队列的时候，rabbitmq 集群根据“队列名称”自动设置是普通集 群模式或镜像队列。

1.3 集群中有两种节点类型
内存节点：只将数据保存到内存
磁盘节点：保存数据到内存和磁盘

内存节点虽然不写入磁盘，但是它执行比磁盘节点要好，集群中，只需要一个磁盘节点来保存数据就足够了如果集群中只有内存节点，那么不能全部停止它们， 否则所有数据消息在服务器全部停机之后都会丢失。

推荐设计架构： 在一个 rabbitmq 集群里，有 3 台或以上机器，其中 1 台使用磁盘模式，其它节 点使用内存模式，内存节点无访问速度更快，由于磁盘 IO 相对较慢，因此可作 为数据备份使用。
————————————————
版权声明：本文为CSDN博主「LlinCK」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42606357/article/details/119121170