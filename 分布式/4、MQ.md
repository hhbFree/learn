### 1、kafka（https://blog.csdn.net/qq_35387940/article/details/100514134）

#### 1.1 消息的传播模式

点对点

- 如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。（服务在分布式情况下，就把不同服务设置为同一个消费组下，就会轮循的去消费）

发布/订阅

- 如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用。（就是分组的数量要小于分区的数量，要不然会有分组消费不到消息）

### 2、rabbitMQ

#### 2.1、消息的传播模式

点对点（队列）

- （服务在分布式情况下，就把不同服务设置为绑定同一个队列下，就会轮循的去消费，也可以设置对应routeKey，进行筛选消费）

发布/订阅（交换机）

- fanout/direct/topic/headers中，fanout/direct/topic都是可以的，一般都是topic，这样可以写正则匹配，如果都满足条件的情况下，对应的队列分别都添加数据，服务分别绑定相同的交换机，绑定不同的队列，队列中的数据相同

避免消息堆积？

1） 采用workqueue，多个消费者监听同一队列。

2）接收到消息以后，而是通过线程池，异步消费。

如何避免消息丢失？

1） 消费者的ACK机制。可以防止消费者丢失消息。

但是，如果在消费者消费之前，MQ就宕机了，消息就没了？

2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化



- bindgkey和routeKey的区别

  rabbit队列要看成消费队列，发送消息时，交换机绑定队列和路由，在发送的时候

  当在direct是没有区别的，因为bindgkey和routeKey必须完全一样，才会发送对应的队列

  在topic时，消费端可以做正则匹配，去接受发送端的数据，满足匹配情况的都会发送对应的队列

  

